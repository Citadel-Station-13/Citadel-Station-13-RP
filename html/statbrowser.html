<!DOCTYPE html>
<html>
<head>
<title>Stat Browser</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Cache-Control" content="max-age=15; must-revalidate" />
<link id="goonStyle" rel="stylesheet" type="text/css" href="browserOutput_white.css" media="all" />
<style>
	body {
		font-family: Verdana, Geneva, Tahoma, sans-serif;
		font-size: 12px !important;
		margin: 0 !important;
		padding: 0 !important;
		overflow-x: hidden;
		overflow-y: scroll;
	}

	body.dark {
		background-color: #131313;
		color: #b2c4dd;
		scrollbar-base-color: #1c1c1c;
		scrollbar-face-color: #3b3b3b;
		scrollbar-3dlight-color: #252525;
		scrollbar-highlight-color: #252525;
		scrollbar-track-color: #1c1c1c;
		scrollbar-arrow-color: #929292;
		scrollbar-shadow-color: #3b3b3b;
	}

	#stat_menu {
		background-color: #F0F0F0;
		position: fixed;
		width: 100%;
		z-index: 100;
	}

	.dark #stat_menu {
		background-color: #202020;
	}

	#stat_content {
		padding: 7px 7px 7px 7px;
	}

	a {
		color: black;
		text-decoration: none
	}

	.dark a {
		color: #b2c4dd;
	}

	a:hover, .dark a:hover {
		text-decoration: underline;
	}

	ul {
		list-style-type: none;
		margin: 0;
		padding: 0;
		background-color: #333;
	}

	li {
		float: left;
	}

	li a {
		display: block;
		color: white;
		text-align: center;
		padding: 14px 16px;
		text-decoration: none;
	}

	li a:hover:not(.active) {
		background-color: #111;
	}

	.button-container {
		display: inline-flex;
		flex-wrap: wrap-reverse;
		flex-direction: row;
		align-items: flex-start;
		overflow-x: hidden;
		white-space: pre-wrap;
		padding: 0 4px;
	}

	.button {
		background-color: #dfdfdf;
		border: 1px solid #cecece;
		border-bottom-width: 2px;
		color: rgba(0, 0, 0, 0.7);
		padding: 6px 4px 4px;
		text-align: center;
		text-decoration: none;
		font-size: 12px;
		margin: 0;
		cursor: pointer;
		transition-duration: 100ms;
		order: 3;
		min-width: 40px;
	}

	.dark button {
		background-color: #222222;
		border-color: #343434;
		color: rgba(255, 255, 255, 0.5);
	}

	.button:hover {
		background-color: #ececec;
		transition-duration: 0;
	}

	.dark button:hover {
		background-color:  #2e2e2e;
	}

	.button:active, .button.active {
		background-color: #ffffff;
		color: black;
		border-top-color: #cecece;
		border-left-color: #cecece;
		border-right-color: #cecece;
		border-bottom-color: #ffffff;
	}

	.dark .button:active, .dark .button.active {
		background-color: #444444;
		color: white;
		border-top-color: #343434;
		border-left-color: #343434;
		border-right-color: #343434;
		border-bottom-color: #ffffff;
	}

	.grid-container {
		margin: -2px;
		margin-right: -15px;
	}

	.grid-item {
		position: relative;
		display: inline-block;
		width: 100%;
		box-sizing: border-box;
		overflow: visible;
		padding: 3px 2px;
		text-decoration: none;
	}

	@media only screen and (min-width: 300px) {
		.grid-item {
			width: 50%;
		}
	}

	@media only screen and (min-width: 430px) {
		.grid-item {
			width: 33%;
		}
	}

	@media only screen and (min-width: 560px) {
		.grid-item {
			width: 25%;
		}
	}

	@media only screen and (min-width: 770px) {
		.grid-item {
			width: 20%;
		}
	}

	.grid-item:hover {
		z-index: 1;
	}

	.grid-item:hover .grid-item-text {
		width: auto;
		text-decoration: underline;
	}

	.grid-item-text {
		display: inline-block;
		width: 100%;
		background-color: #ffffff;
		margin: 0 -6px;
		padding: 0 6px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		pointer-events: none;
	}

	.dark .grid-item-text {
		background-color: #131313;
	}

	.link {
		display: inline;
		background: none;
		border: none;
		padding: 7px 14px;
		color: black;
		text-decoration: none;
		cursor: pointer;
		font-size: 13px;
		margin: 2px 2px;
	}

	.dark .link {
		color: #abc6ec;
	}

	.link:hover {
		text-decoration: underline;
	}

	img {
		-ms-interpolation-mode: nearest-neighbor;
		image-rendering: pixelated;
	}

	.interview_panel_controls, .interview_panel_stats {
		margin-bottom: 10px;
	}
</style>
</head>
<body>
<ul id="stat_menu" class="button-container"></ul>
<div id="stat_submenu"></div>
<div id="stat_content"></div>
<script>
// Polyfills and compatibility ------------------------------------------------
var decoder = decodeURIComponent || unescape;
var PROP_ADD_EVENT_LISTENER = (document.addEventListener ? 'addEventListener' : 'attachEvent'); // IE8 handling for Wine users
var PROP_TEXT_CONTENT = (typeof document.body.textContent != 'undefined') ? 'textContent' : 'innerText';
if(!Array.prototype.includes) {
	Array.prototype.includes = function(thing) {
		for(var i = 0; i < this.length; i++) {
			if(this[i] == thing) return true;
		}
		return false;
	}
}
if (!String.prototype.trim) {
	String.prototype.trim = function () {
		return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};
}
/*\
|*|
|*|  Polyfill which enables the passage of arbitrary arguments to the
|*|  callback functions of JavaScript timers (HTML5 standard syntax).
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/window.setInterval
|*|
|*|  Syntax:
|*|  var timeoutID = window.setTimeout(func, delay[, arg1, arg2, ...]);
|*|  var timeoutID = window.setTimeout(code, delay);
|*|  var intervalID = window.setInterval(func, delay[, arg1, arg2, ...]);
|*|  var intervalID = window.setInterval(code, delay);
|*|
\*/
(function() {
  setTimeout(function(arg1) {
    if (arg1 === 'test') {
      // feature test is passed, no need for polyfill
      return;
    }
    var __nativeST__ = window.setTimeout;
    window.setTimeout = function(vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */ ) {
      var aArgs = Array.prototype.slice.call(arguments, 2);
      return __nativeST__(vCallback instanceof Function ? function() {
        vCallback.apply(null, aArgs);
      } : vCallback, nDelay);
    };
  }, 0, 'test');

  var interval = setInterval(function(arg1) {
    clearInterval(interval);
    if (arg1 === 'test') {
      // feature test is passed, no need for polyfill
      return;
    }
    var __nativeSI__ = window.setInterval;
    window.setInterval = function(vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */ ) {
      var aArgs = Array.prototype.slice.call(arguments, 2);
      return __nativeSI__(vCallback instanceof Function ? function() {
        vCallback.apply(null, aArgs);
      } : vCallback, nDelay);
    };
  }, 0, 'test');
}())

///////////////////////// CONSTANTS /////////////////////

const ELEMENT_ID_MENU = "stat_menu"
const ELEMENT_ID_SUBMENU = "stat_submenu"
const ELEMENT_ID_CONTENT = "stat_content"
const SKIN_ID_MAP = "map";
const ELEMENT_ID_ATOM_TABLE = "atom_elem"

/// how long to wait before re-loading missing images
var IMAGE_RETRY_DELAY = 1000;

/////////////////////// ELEMENTS ////////////////////////

var stat_menu = document.getElementById(ELEMENT_ID_MENU);
var stat_submenu = document.getElementById(ELEMENT_ID_SUBMENU);
var stat_content = document.getElementById(ELEMENT_ID_CONTENT);

// Status panel implementation ------------------------------------------------
var href_token = null;
var imageRetryLimit = 50;
var storedimages = [];
var split_admin_tabs = false;

var connected = false;
var commandQueue = [];

///////////////////// BOOT //////////////////////////////

window.onload = function() {
	window_boot();
};

function window_boot() {
	register_events()
	transmit_ready()
}

function register_events() {
	// restore focus after press
	document[PROP_ADD_EVENT_LISTENER]("mouseup", winset_focus_map);
	// restore focus after press
	document[PROP_ADD_EVENT_LISTENER]("keyup", winset_focus_map);
}

/////////////////////// DATA ////////////////////////////

// for verbs ; tab name = list ( verb1, verb2, ... );
var verbs = {};
// for stat ; list(entry, ...)
// entry format:
// 1. text: displayed verbatim, html allowed
// 2. text = text: displayed as key --> value with the obligatory tab/spacing
// 3. array [key, value, act]: clicking on the entry will trigger act with that act.
var data = []
// admin href token
var admin_token = null;

// for listed turf
var listed_turf_contents = null;
var listed_turf_name = null;
var listed_turf_icon = null;
var listed_turf_ref = null;

//////////////// CALLED FROM BYOND //////////////////////

/// called for shutdown
function byond_shutdown() {

}

/// called for init
function byond_init() {

}

/// called on data update
function byond_push(data) {
	data = [];
	_push_data(data);
	redraw_content();
}

/// called on data update to append
function byond_append(data) {
	_push_data(data);
	redraw_content();
}

/// special 2 part push
function byond_update(cdata, ddata) {
	// push both c(ached) data and d(ynamic) data at once.
	data = [];
	_push_data(cdata);
	_push_data(ddata);
	redraw_content();
}


function _push_data(data) {
	var parsed = JSON.parse(data);
	for(var i = 0; i < parsed.length; i++){
		if(parsed[i] == null){
			data.push(parsed[i]);
		}
	}
}

/// called to add tab
function byond_add_tab(tab) {
	ensure_tab(tab);
}

/// called to remove tab
function byond_remove_tab(tab) {
	erase_tab(tab);
}

/// called to clear tabs
function byond_clear_tabs() {
	erase_tabs();
}

/// called to add verb
function byond_add_verb(name, category) {

}

/// called to remove verb
function byond_remove_verb(name, category) {

}

/// called to add multiple verbs: same format as init verbs
function byond_add_verbs(data) {


}

/// called to remove multiple verbs: same format as init verbs
function byond_remove_verbs(data) {

}

/// called to init verbs: takes object of categories to lists of names. throws out any verbs not in this.
function byond_init_verbs(data) {

}

/// called to remove listed turf
function byond_turf_unset(){
	listed_turf_name = null;
	listed_turf_icon = null;
	listed_turf_contents = null;
	erase_turf_tab();
}

/// called to set listed turf
function byond_turf_set(name, ref, icon, contents){
	listed_turf_name = name;
	listed_turf_icon = icon;
	listed_turf_ref = ref;
	listed_turf_contents = JSON.parse(contents);
	ensure_turf_tab();
	// switch to it
	change_tab("Turf");
}

/// called to add an atom from listed turf
function byond_turf_add(data){

}

/// called to remove an atom from listed turf
function byond_turf_del(ref){

}

/// called to give us a href token
function byond_grant_token(token){
	href_token = token;
}

/// called ot dispose of our href token
function byond_dispose_token(token){
	href_token = null;
}


//////////////// TRANSMIT TO BYOND //////////////////////

/// command queue
var command_queue = [];

/// direct send, do not use
function __transmit_verb(cmd) {
	var href = "byond://winset?command=" + cmd;
	window.location.href = href;
}

/// queues or sends
function transmit_verb(cmd) {
	if(connected){
		__transmit_verb(cmd);
	}
	else{
		command_queue.push(cm)
	}
}

/// immediate sends
function transmit_href(action, data = null) {

}

/// flushes queue
function transmit_flush_queue() {
	for(var i = 0; i < command_queue.length; i++){
		__transmit_verb(command_queue[i]);
	}
	command_queue.length = 0
}

/// informs byond we are ready
function transmit_ready() {
	transmit_verb(".statpanel_ready");
}

//////////////////// WINSET / WINGET / SKIN /////////////

function winset_focus_map() {
	yield_invoke(function() {window.location.href = "byond://winset?" + SKIN_ID_MAP + ".focus=true";});
}

/////////////////////// STARTUP /////////////////////////

//////////////////////// SHUTDOWN ///////////////////////

/////////////////////// CONNECTION //////////////////////

//////////////////////// MAIN ///////////////////////////

function redraw_menu(){

}

function redraw_content(){
	var tab = active_tab;
	if(!tab) {
		draw_loading();
		return;
	}
	if(tab == "Turf"){
		draw_turf();
	}
	else if(all_tabs.includes(tab)){
		draw_tab(tab);
		return;
	}
	else{
		draw_error();
		return;
	}
}

//////////////////////// TABS ///////////////////////////

/// tabs
var all_tabs = [];
/// active tab
var active_tab;

/// id for tab
function id_tab(name) {
	return "t_" + name;
}

/// ensure a tab is there
function ensure_tab(name) {

}

/// ensure a tab *isn't* there
function erase_tab(name) {

}

/// clear tabs that don't have verbs
function erase_tabs() {

}

/// swap tabs - input is tab ID, NOT NAME.
function change_tab(tab){
	// already there? don't bother
	if(tab == active_tab){
		return;
	}
	// grab last
	var last_tab = document.getElementById(id_tab(active_tab));
	// set active
	active_tab = tab;
	// grab current
	var next_tab = document.getElementById(id_tab(active_tab));
	// transmit to byond
	transmit_verb(".statpanel_tab " + tab);
	// so UNFORTUNATELY we're going to wipe data
	// in the future we want to have a system where we can cache last
	// for now, well, the subsystem does fire every 0.4 seconds.
	data = [];

	// change ui
	if(last_tab){
		last_tab.className = "button";
	}
	if(next_tab){
		next_tab.className = "button active";
	}
	// redraw
	redraw_content();
}

// wrappers for turf tabs
function ensure_turf_tab() { ensure_tab("Turf"); }
function erase_turf_tab() { erase_tab("Turf"); }

///////////////////////// VERBS /////////////////////////

///////////////////// DRAWING - MISC ////////////////////

function draw_loading(){
	stat_content[PROP_TEXT_CONTENT] = "Loading..."
}

function draw_error() {
	stat_content[PROP_TEXT_CONTENT] = "<center><h1>Statpanel errored. Contact an admin/coder, and reconnect.</h1></center>"
}

///////////////////// DRAWING - TABS ////////////////////

function draw_tab(tab) {
	// wipe
	stat_content[PROP_TEXT_CONTENT] = "";
	// draw verbs
	if(verbs[tab] != undefined) {
		var verb_table = document.createElement("div");
		verb_table.className = "grid-container";
		var iterating = verbs[tab]
		for(var i = 0; i < iterating.length; ++i) {
			var verb = iterating[i];
			var a = document.createElemtn("a");
			a.href = "#";
			a.onclick = lambda_onclick_verb(verb.replace(/\s/g, "-"));
			a.className = "grid-item";
			var t = document.createElement("span");
			t[PROP_TEXT_CONTENT] = verb;
			t.className = "grid-item-text";
			a.appendChild(t);
			verb_table.appendChild(a);
		}
		stat_content.appendChild(verb_table)
	}
	// draw data
	if(data.length != 0) {
		for(var i = 0; i < data.length; ++i) {
			var entry = data[i];
			// shitcode central: decode data
			var dtype = typeof entry;
			if(dtype == "string") {
				// just text; render normally

				return;
			}
			// it's not just string, so it's an array
			if(entry.length == 2) {
				// simple k-v entry
			}
			else if(entry.length == 3) {
				// k-v with value being clickable
			}
		}
	}
}

///////////////////// DRAWING - TURFS ///////////////////

function draw_turf() {
	// wipe
	stat_content[PROP_TEXT_CONTENT] = "";
	// create table
	var table = document.createElement("table");
	table.id = ELEMENT_ID_ATOM_TABLE;

	// draw turf itself
	draw_atom(listed_turf_name, listed_turf_icon, listed_turf_ref, table);
}

/// id for atom div
function id_atom(ref){
	return "a_" + ref;
}

function draw_atom(name, icon, ref, table){
	// if none passed in, probably an atom is being injected as opposed to a full redraw
	if(!table) {
		// resolve table
		table = document.getElementById(ELEMENT_ID_ATOM_TABLE);
		// if still not here we don't bother
		if(!table) {
			return;
		}
		// since it's not a full draw we want to de-dupe
		var existing = id_atom(ref);
		if(existing){
			// don't make another
			// todo: update existing instead of just returning
			return;
		}
	}
	// outer div
	var adiv = document.createElement("div");
	adiv.id = id_atom(ref);
	// inner div
	var ldiv = document.createElement("div");
	ldiv.className = "link";
	ldiv.onmousedown = lambda_onclick_atom(ref);
	ldiv[PROP_TEXT_CONTENT] = name;
	// image
	var img = document.createElement("img");
	img.onerror = lambda_reload_image(img);
	img.src = icon;
	// add
	adiv.appendChild(img);
	adiv.appendChild(ldiv);
	// append
	table.appendChild(adiv);
}

function dispose_atom(ref){
	var table = document.getElementById(ELEMENT_ID_ATOM_TABLE);
	if(!table){
		return;
	}
	var child = document.getElementById(id_atom(ref));
	if(!child){
		return;
	}
	table.removeChild(child);
}

function atom_invoke(event, ref){
	// transmit the click with params encoded as byond params so Click() needs to do
	// minimal work

	switch(event.button){
		case 1:
			// middle
			break;
		case 2:
			// right
			break;
		default:
			// left

	}
	if(e.shiftKey){

	}
	if(e.ctrlKey){

	}
	if(e.altKey){

	}

}

/////////// FUNCTION FUNCTIONS (IE IS TERRIBLE) /////////

/**
 * creates the onclick for verbs
 */
function lambda_onclick_verb(verb) {
	return function(e) {
		yield_invoke(function() {transmit_verb(verb);});
	}
}

/**
 * creates the onclick for atoms
 */
 function lambda_onclick_atom(ref) {
	return function(e) {
		e.preventDefault();
		atom_invoke(e, ref);
	}
 }

/**
 * creates the onerror function used to load things
 */
function lambda_reload_image(node) {
	var re_ref = node;
	return setTimeout(function() {
		var old_src = re_ref.old_src
		re_ref.src = null;
		re_ref.src = old_src + '#' + (Math.random() * 1000);
	}, IMAGE_RETRY_DELAY);
}

/**
 * fires a function after the current stack/whatever
 * used to yield focus and other stuff
 */
function yield_invoke(f) {
	setTimeout(f, 0);
}

/////////////////////////////////////////////////////////


// Any BYOND commands that could result in the client's focus changing go through this
// to ensure that when we relinquish our focus, we don't do it after the result of
// a command has already taken focus for itself.
function run_after_focus(callback) {
	setTimeout(callback, 0);
}

function connected_to_server() {
	if (connected) {
		return;
	}

	connected = true;

	for (var index = 0; index < commandQueue.length; index++) {
		// This is just setting it a lot, is this not going to cancel?
		window.location.href = commandQueue[index];
	}

	commandQueue = [];
}

function update_split_admin_tabs(status) {
	status = (status == true);

	if (split_admin_tabs !== status) {
		if (split_admin_tabs === true) {
			removeStatusTab("Events");
			removeStatusTab("Fun");
			removeStatusTab("Game");
		}
		update_verbs();
	}
	split_admin_tabs = status;
}

function createStatusTab(name) {
	if (name.indexOf(".") != -1) {
		var splitName = name.split(".");
		if (split_admin_tabs && splitName[0] === "Admin")
			name = splitName[1];
		else
			name = splitName[0];
	}
	if(document.getElementById(name) || name.trim() == "")
		return;
	if(!verb_tabs.includes(name) && !permanent_tabs.includes(name))
		return;
	var B = document.createElement("BUTTON");
	B.onclick = function() {
		tab_change(name);
		this.blur();
	};
	B.id = name;
	B[PROP_TEXT_CONTENT] = name;
	B.className = "button";
	//ORDERING ALPHABETICALLY
	B.style.order = name.charCodeAt(0);
	if(name == "Status" || name == "MC")
		B.style.order = name == "Status" ? 1 : 2;
	//END ORDERING
	stat_menu.appendChild(B);
	SendTabToByond(name);
	stat_submenu.style.height = stat_menu.clientHeight + 'px';
}

function removeStatusTab(name) {
	if(!document.getElementById(name) || permanent_tabs.includes(name))
		return;
	for (var i = verb_tabs.length - 1; i >= 0; --i) {
		if (verb_tabs[i] == name) {
			verb_tabs.splice(i, 1);
		}
	}
	stat_menu.removeChild(document.getElementById(name));
	TakeTabFromByond(name);
	stat_submenu.style.height = stat_menu.clientHeight + 'px';
}

function sortVerbs() {
	verbs.sort(function (a, b) {
		var selector = a[0] == b[0] ? 1 : 0;
		if (a[selector].toUpperCase() < b[selector].toUpperCase()) {
			return 1;
		}
		else if (a[selector].toUpperCase() > b[selector].toUpperCase()) {
			return -1;
		}
		return 0;
	})
}

window.onresize = function () {
	stat_submenu.style.height = stat_menu.clientHeight + 'px';
}

function addPermanentTab(name) {
	if(!permanent_tabs.includes(name))
		permanent_tabs.push(name);
	createStatusTab(name);
}

function removePermanentTab(name) {
	for (var i = permanent_tabs.length - 1; i >= 0; --i) {
		if (permanent_tabs[i] == name) {
			permanent_tabs.splice(i, 1);
		}
	}
	removeStatusTab(name);
}

function checkStatusTab() {
	for(var i=0; i < stat_menu.children.length; i++)
		if(!verb_tabs.includes(stat_menu.children[i].id) && !permanent_tabs.includes(stat_menu.children[i].id))
			stat_menu.removeChild(stat_menu.children[i]);
}

function remove_verb(v) {
	var verb_to_remove = v; // to_remove = [verb:category, verb:name]
	for(var i = verbs.length - 1; i >= 0; i--){
		var part_to_remove = verbs[i];
		if(part_to_remove[1] == verb_to_remove[1]){
			verbs.splice(i, 1)
		}
	}
}

function check_verbs() {
	for(var v = verb_tabs.length - 1; v >= 0; v--){
		verbs_cat_check(verb_tabs[v]);
	}
}

function verbs_cat_check(cat) {
	var tabCat = cat;
	if (cat.indexOf(".") != -1) {
		var splitName = cat.split(".");
		if (split_admin_tabs && splitName[0] === "Admin")
			tabCat = splitName[1];
		else
			tabCat = splitName[0];
	}
	var verbs_in_cat = 0;
	var verbcat = "";
	if(!verb_tabs.includes(tabCat)){
		removeStatusTab(tabCat);
		return;
	}
	for(var v = 0; v < verbs.length; v++){
		var part = verbs[v];
		verbcat = part[0];
		if (verbcat.indexOf(".") != -1) {
			var splitName = verbcat.split(".");
			if (split_admin_tabs && splitName[0] === "Admin")
				verbcat = splitName[1];
			else
				verbcat = splitName[0];
		}
		if(verbcat != tabCat || verbcat.trim() == ""){
			continue;
		}
		else{
			verbs_in_cat = 1;
			break; // we only need one
		}
	}
	if(verbs_in_cat != 1) {
		removeStatusTab(tabCat);
		if(current_tab == tabCat)
			tab_change("Status");
	}
}

function findVerbindex(name, verblist) {
	for(var i = 0; i < verblist.length; i++) {
		var part = verblist[i];
		if(part[1] == name)
			return i;
	}
}
function wipe_verbs() {
	verbs = [["", ""]];
	verb_tabs = [];
	checkStatusTab(); // remove all empty verb tabs
}

function update_verbs() {
	wipe_verbs();
	transmit_verb("Update-Verbs");
}

function add_verb_list(v) {
	var to_add = JSON.parse(v); // list of a list with category and verb inside it
	to_add.sort(); // sort what we're adding
	for(var i = 0; i < to_add.length; i++) {
		var part = to_add[i];
		if(!part[0])
			continue;
		var category = part[0];
		if (category.indexOf(".") != -1) {
			var splitName = category.split(".");
			if (split_admin_tabs && splitName[0] === "Admin")
				category = splitName[1];
			else
				category = splitName[0];
		}
		if(findVerbindex(part[1], verbs))
			continue;
		if(verb_tabs.includes(category)){
			verbs.push(part);
			if(current_tab == category) {
				draw_verbs(category); // redraw if we added a verb to the tab we're currently in
			}
		} else if(category) {
			verb_tabs.push(category);
			verbs.push(part);
			createStatusTab(category);
		}
	}
}

function remove_verb_list(v) {
	var to_remove = JSON.parse(v);
	for(var i = 0; i < to_remove.length; i++) {
		remove_verb(to_remove[i]);
	}
	check_verbs();
	sortVerbs();
	if(verb_tabs.includes(current_tab))
		draw_verbs(current_tab);
}

// passes a 2D list of (verbcategory, verbname) creates tabs and adds verbs to respective list
// example (IC, Say)
function init_verbs(c, v) {
	connected_to_server();
	wipe_verbs(); // remove all verb categories so we can replace them
	checkStatusTab(); // remove all status tabs
	verb_tabs = JSON.parse(c);
	verb_tabs.sort(); // sort it
	var do_update = false;
	var cat = "";
	for(var i = 0; i < verb_tabs.length; i++){
		cat = verb_tabs[i];
		createStatusTab(cat); // create a category if the verb doesn't exist yet
	}
	if(verb_tabs.includes(current_tab)) {
		do_update = true;
	}
	if(v) {
		add_verb_list(v);
		sortVerbs(); // sort them
		if(do_update) {
			draw_verbs(current_tab);
		}
	}
	SendTabsToByond();
}

function SendTabsToByond(){
	var tabstosend = [];
	tabstosend = tabstosend.concat(permanent_tabs, verb_tabs);
	for(var i=0; i < tabstosend.length; i++){
		SendTabToByond(tabstosend[i]);
	}
}

function SendTabToByond(tab) {
	transmit_verb("Send-Tabs " + tab);
}

//Byond can't have this tab anymore since we're removing it
function TakeTabFromByond(tab) {
	transmit_verb("Remove-Tabs " + tab);
}

/// citadel statvoting
function update_voting(vote_data) {
	vote_parts = JSON.parse(vote_data);
	if(current_tab == "Status")
		draw_status();
}

function update_mc(global_mc_data, coords_entry) {
	mc_tab_parts = JSON.parse(global_mc_data);
	mc_tab_parts.splice(0,0,["Location:",coords_entry]);
	if(!verb_tabs.includes("MC"))
		verb_tabs.push("MC");
	createStatusTab("MC");
	if(current_tab == "MC")
		draw_mc();
}

function remove_mc() {
	removeStatusTab("MC");
	if(current_tab == "MC")
		tab_change("Status");
}
function remove_spells() {
	for(var s = 0; s < spell_tabs.length; s++){
		removeStatusTab(spell_tabs[s]);
	}
}

function init_spells() {
	var cat = "";
	for(var i = 0; i < spell_tabs.length; i++) {
		cat = spell_tabs[i];
		if(cat.length > 0) {
			verb_tabs.push(cat);
			createStatusTab(cat);
		}
	}
}

function check_spells() {
	for(var v = 0; v < spell_tabs.length; v++)
		spell_cat_check(spell_tabs[v]);
}
function spell_cat_check(cat) {
	var spells_in_cat = 0;
	var spellcat = "";
	for(var s = 0; s < spells.length; s++){
		var spell = spells[s];
		spellcat = spell[0];
		if(spellcat == cat){
			spells_in_cat++;
		}
	}
	if(spells_in_cat < 1) {
		removeStatusTab(cat);
	}
}
function update_spells(t, s) {
	spell_tabs = JSON.parse(t);
	var do_update = false;
	if(spell_tabs.includes(current_tab)) {
		do_update = true;
	}
	init_spells();
	if(s) {
		spells = JSON.parse(s);
		if(do_update) {
			draw_spells(current_tab);
		}
	} else {
		remove_spells();
	}
}

function draw_debug() {
	stat_content[PROP_TEXT_CONTENT] = "";
	var wipeverbstabs = document.createElement("div");
	var link = document.createElement("a");
	link.onclick = function() {wipe_verbs()};
	link[PROP_TEXT_CONTENT] = "Wipe All Verbs";
	wipeverbstabs.appendChild(link);
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(wipeverbstabs);
	var wipeUpdateVerbsTabs = document.createElement("div");
	var updateLink = document.createElement("a");
	updateLink.onclick = function() {update_verbs()};
	updateLink[PROP_TEXT_CONTENT] = "Wipe and Update All Verbs";
	wipeUpdateVerbsTabs.appendChild(updateLink);
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(wipeUpdateVerbsTabs);
	var text = document.createElement("div");
	text[PROP_TEXT_CONTENT] = "Verb Tabs:";
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(text);
	var table1 = document.createElement("table");
	for(var i=0; i < verb_tabs.length ; i++) {
		var part = verb_tabs[i];
		// Hide subgroups except admin subgroups if they are split
		if (verb_tabs[i].lastIndexOf(".") != -1) {
			var splitName = verb_tabs[i].split(".");
			if (split_admin_tabs && splitName[0] === "Admin")
				part = splitName[1];
			else
				continue;
		}
		var tr = document.createElement("tr");
		var td1 = document.createElement("td");
		td1[PROP_TEXT_CONTENT] = part;
		var a = document.createElement("a");
		a.onclick = function (part) {
			return function() {removeStatusTab(part)};
		}(part);
		a[PROP_TEXT_CONTENT] = " Delete Tab " + part;
		td1.appendChild(a);
		tr.appendChild(td1);
		table1.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table1);
	var header2 = document.createElement("div");
	header2[PROP_TEXT_CONTENT] = "Verbs:";
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(header2);
	var table2 = document.createElement("table");
	for(var v = 0; v < verbs.length; v++) {
		var part2 = verbs[v];
		var trr = document.createElement("tr");
		var tdd1 = document.createElement("td");
		tdd1[PROP_TEXT_CONTENT] = part2[0];
		var tdd2 = document.createElement("td");
		tdd2[PROP_TEXT_CONTENT] = part2[1];
		trr.appendChild(tdd1);
		trr.appendChild(tdd2);
		table2.appendChild(trr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table2);
	var text3 = document.createElement("div");
	text3[PROP_TEXT_CONTENT] = "Permanent Tabs:";
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(text3);
	var table3 = document.createElement("table");
	for(var i=0; i < permanent_tabs.length ; i++) {
		var part3 = permanent_tabs[i];
		var trrr = document.createElement("tr");
		var tddd1 = document.createElement("td");
		tddd1[PROP_TEXT_CONTENT] = part3;
		trrr.appendChild(tddd1);
		table3.appendChild(trrr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table3);

}
function draw_status() {
	if(!document.getElementById("Status")) {
		createStatusTab("Status");
		current_tab = "Status";
	}
	stat_content[PROP_TEXT_CONTENT] = '';
	for(var i = 0; i < status_tab_parts.length; i++) {
		if(status_tab_parts[i].trim() == "") {
			document.getElementById(ELEMENT_ID_CONTENT).appendChild(document.createElement("br"));
		} else {
			var div = document.createElement("div");
			div[PROP_TEXT_CONTENT] = status_tab_parts[i];
			document.getElementById(ELEMENT_ID_CONTENT).appendChild(div);
		}
	}
	//voting shitcode. See mc for more info.
	if(vote_parts && vote_parts[0][0]) { //null verification.
		var table = document.createElement("table");
		for(var i = 0; i < vote_parts.length; i++) {
			var part = vote_parts[i];
			var tr = document.createElement("tr");
			var td1 = document.createElement("td");
			td1[PROP_TEXT_CONTENT] = part[0];
			var td2 = document.createElement("td");
			if(part[2]) {
				var a = document.createElement("a");
				if(part[2] === "disabled") {
					a.href = "byond://winset?command=Vote";
				} else {
					a.href = "?src=" + part[2];
				}
				a[PROP_TEXT_CONTENT] = part[1];
				td2.appendChild(a);
			} else {
				td2[PROP_TEXT_CONTENT] = part[1];
			}
			tr.appendChild(td1);
			tr.appendChild(td2);
			table.appendChild(tr);
		}
		document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
	}
	if(verb_tabs.length == 0 || !verbs)
	{
		transmit_verb("Fix-Stat-Panel");
	}
}

function draw_mc() {
	stat_content[PROP_TEXT_CONTENT] = "";
	var table = document.createElement("table");
	for(var i = 0; i < mc_tab_parts.length; i++) {
		var part = mc_tab_parts[i];
		var tr = document.createElement("tr");
		var td1 = document.createElement("td");
		td1[PROP_TEXT_CONTENT] = part[0];
		var td2 = document.createElement("td");
		if(part[2]) {
			var a = document.createElement("a");
			a.href = "?_src_=vars;admin_token=" + href_token + ";Vars=" + part[2];
			a[PROP_TEXT_CONTENT] = part[1];
			td2.appendChild(a);
		} else {
			td2[PROP_TEXT_CONTENT] = part[1];
		}
		tr.appendChild(td1);
		tr.appendChild(td2);
		table.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}
function update_tickets(T){
	tickets = JSON.parse(T);
	if(!verb_tabs.includes("Tickets")) {
		verb_tabs.push("Tickets");
		addPermanentTab("Tickets");
	}
	if(current_tab == "Tickets")
		draw_tickets();
}
function update_interviews(I){
	interviewManager = JSON.parse(I);
	if(current_tab == "Tickets")
		draw_interviews();
}
function update_sdql2(S) {
	sdql2 = JSON.parse(S);
	if(sdql2.length > 0 && !verb_tabs.includes("SDQL2")) {
		verb_tabs.push("SDQL2");
		addPermanentTab("SDQL2");
	}
	if(current_tab == "SDQL2")
		draw_sdql2();
}

function remove_sdql2() {
	if(sdql2) {
		sdql2 = [];
		removePermanentTab("SDQL2");
		if(current_tab == "SDQL2")
			tab_change("Status");
	}
	checkStatusTab();
}

function remove_tickets() {
	if(tickets) {
		tickets = [];
		removePermanentTab("Tickets");
		if(current_tab == "Tickets")
			tab_change("Status");
	}
	checkStatusTab();
}

function remove_interviews() {
	if(tickets) {
		tickets = [];
	}
	checkStatusTab();
}

// removes MC, Tickets and MC tabs.
function remove_admin_tabs() {
	href_token = null;
	remove_mc();
	remove_tickets();
	remove_sdql2();
//	remove_interviews();
}

function add_admin_tabs(ht) {
	href_token = ht;
	addPermanentTab("MC");
	addPermanentTab("Tickets");
}
function create_listedturf(TN) {
	remove_listedturf(); // remove the last one if we had one
	turfname = JSON.parse(TN);
	addPermanentTab(turfname);
	tab_change(turfname);
}
function update_listedturf(TC) {
	turfcontents = JSON.parse(TC);
	if(current_tab == turfname)
		draw_listedturf();
}
function iconError() {
	var that = this;
	setTimeout(function() {
		var current_attempts = that.id; // a bit of a hack, change this if we need to call on img id's later
		if(!current_attempts)
			that.id = 1;
		if (current_attempts > imageRetryLimit)
			return;
		var src = that.src;
		that.src = null;
		that.src = src + '#' + current_attempts;
		that.id++;
		draw_listedturf();
	}, IMAGE_RETRY_DELAY);
}
function draw_listedturf() {
	stat_content[PROP_TEXT_CONTENT] = "";
	var table = document.createElement("table");
	for(var i = 0; i < turfcontents.length; i++) {
		var part = turfcontents[i];
		if(storedimages[part[1]] == null && part[2]) {
			var img = document.createElement("img");
			img.src = part[2];
			img.id = part[1];
			storedimages[part[1]] = part[2];
			img.onerror = function() {
				iconError();
			};
			table.appendChild(img);
		} else {
			var img = document.createElement("img");
			img.onerror = function() {
				iconError();
			};
			img.src = storedimages[part[1]];
			img.id = part[1];
			table.appendChild(img);
		}
		var b = document.createElement("div");
		var clickcatcher = "";
		b.className = "link";
		b.onmousedown = function (part) {
			// The outer function is used to close over a fresh "part" variable,
			// rather than every onmousedown getting the "part" of the last entry.
			return function(e) {
				e.preventDefault();
				clickcatcher = "?src=_statpanel_;statpanel_item_target=" + part[1];
				switch(e.button){
					case 1:
						clickcatcher += ";statpanel_item_click=middle"
						break;
					case 2:
						clickcatcher += ";statpanel_item_click=right"
						break;
					default:
						clickcatcher += ";statpanel_item_click=left"
				}
				if(e.shiftKey){
					clickcatcher += ";statpanel_item_shiftclick=1";
				}
				if(e.ctrlKey){
					clickcatcher += ";statpanel_item_ctrlclick=1";
				}
				if(e.altKey) {
					clickcatcher += ";statpanel_item_altclick=1";
				}
				window.location.href = clickcatcher;
			}
		}(part);
		b[PROP_TEXT_CONTENT] = part[0];
		table.appendChild(b);
		table.appendChild(document.createElement("br"));
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}

function remove_listedturf() {
	removePermanentTab(turfname);
	checkStatusTab();
	if(current_tab == turfname)
		tab_change("Status");
}
function draw_sdql2(){
	stat_content[PROP_TEXT_CONTENT] = "";
	var table = document.createElement("table");
	for(var i = 0; i < sdql2.length; i++) {
		var part = sdql2[i];
		var tr = document.createElement("tr");
		var td1 = document.createElement("td");
		td1[PROP_TEXT_CONTENT] = part[0];
		var td2 = document.createElement("td");
		if(part[2]) {
			var a = document.createElement("a");
			a.href = "?src=" + "_statpanel_" + ";statpanel_item_target=" + part[2] + ";statpanel_item_click=left";
			a[PROP_TEXT_CONTENT] = part[1];
			td2.appendChild(a);
		} else {
			td2[PROP_TEXT_CONTENT] = part[1];
		}
		tr.appendChild(td1);
		tr.appendChild(td2);
		table.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}

function draw_tickets() {
	stat_content[PROP_TEXT_CONTENT] = "";
	var table = document.createElement("table");
	if(!tickets)
		return;
	for(var i = 0; i < tickets.length; i++) {
		var part = tickets[i];
		var tr = document.createElement("tr");
		var td1 = document.createElement("td");
		td1[PROP_TEXT_CONTENT] = part[0];
		var td2 = document.createElement("td");
		if(part[2]) {
			var a = document.createElement("a");
			a.href = "?_src_=holder;admin_token=" + href_token + ";ahelp=" + part[2] + ";ahelp_action=ticket;statpanel_item_click=left;action=ticket" ;
			a[PROP_TEXT_CONTENT] = part[1];
			td2.appendChild(a);
		} else if(part[3]){
			var a = document.createElement("a");
			a.href = "?src=_statpanel_" + ";statpanel_item_target=" + part[3] + ";statpanel_item_click=left";
			a[PROP_TEXT_CONTENT] = part[1];
			td2.appendChild(a);
		} else {
			td2[PROP_TEXT_CONTENT] = part[1];
		}
		tr.appendChild(td1);
		tr.appendChild(td2);
		table.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}

function draw_interviews() {
	var body = document.createElement("div");
	var header = document.createElement("h3");
	header[PROP_TEXT_CONTENT] = "Interviews";
	body.appendChild(header);
	var manDiv = document.createElement("div");
	manDiv.className = "interview_panel_controls"
	var manLink = document.createElement("a");
	manLink[PROP_TEXT_CONTENT] = "Open Interview Manager Panel";
	manLink.href = "?_src_=holder;admin_token=" + href_token + ";interview_man=1;statpanel_item_click=left";
	manDiv.appendChild(manLink);
	body.appendChild(manDiv);

	// List interview stats
	var statsDiv = document.createElement("table");
	statsDiv.className="interview_panel_stats";
	for (var key in interviewManager.status) {
		var d = document.createElement("div");
		var tr = document.createElement("tr");
		var stat_name = document.createElement("td");
		var stat_text = document.createElement("td");
		stat_name[PROP_TEXT_CONTENT] = key;
		stat_text[PROP_TEXT_CONTENT] = interviewManager.status[key];
		tr.appendChild(stat_name);
		tr.appendChild(stat_text);
		statsDiv.appendChild(tr);
	}
	body.appendChild(statsDiv);
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(body);

	// List interviews if any are open
	var table = document.createElement("table");
	table.className = "interview_panel_table";
	if(!interviewManager)
		return;
	for(var i = 0; i < interviewManager.interviews.length; i++) {
		var part = interviewManager.interviews[i];
		var tr = document.createElement("tr");
		var td = document.createElement("td");
		var a = document.createElement("a");
		a[PROP_TEXT_CONTENT] = part["status"];
		a.href = "?_src_=holder;admin_token=" + href_token + ";interview=" + part["ref"] + ";statpanel_item_click=left";
		td.appendChild(a);
		tr.appendChild(td);
		table.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}

function draw_spells(cat) {
	stat_content[PROP_TEXT_CONTENT] = "";
	var table = document.createElement("table");
	for(var i = 0; i < spells.length; i++) {
		var part = spells[i];
		if(part[0] != cat) continue;
		var tr = document.createElement("tr");
		var td1 = document.createElement("td");
		td1[PROP_TEXT_CONTENT] = part[1];
		var td2 = document.createElement("td");
		if(part[3]) {
			var a = document.createElement("a");
			a.href = "?src=" + part[3] + ";statpanel_item_click=left";
			a[PROP_TEXT_CONTENT] = part[2];
			td2.appendChild(a);
		} else {
			td2[PROP_TEXT_CONTENT] = part[2];
		}
		tr.appendChild(td1);
		tr.appendChild(td2);
		table.appendChild(tr);
	}
	document.getElementById(ELEMENT_ID_CONTENT).appendChild(table);
}
function set_theme(which) {
	if (which == "light") {
		document.body.className = "";
		set_style_sheet("browserOutput_white");
	} else if (which == "dark") {
		document.body.className = "dark";
		set_style_sheet("browserOutput");
	}
}

function set_style_sheet(sheet) {
	if(document.getElementById("goonStyle")) {
		var currentSheet = document.getElementById("goonStyle");
		currentSheet.parentElement.removeChild(currentSheet);
	}
	var head = document.getElementsByTagName('head')[0];
	var sheetElement = document.createElement("link");
	sheetElement.id = "goonStyle";
	sheetElement.rel = "stylesheet";
	sheetElement.type = "text/css";
	sheetElement.href = sheet + ".css";
	sheetElement.media = 'all';
	head.appendChild(sheetElement);
}

if(!current_tab) {
	addPermanentTab("Status");
	tab_change("Status");
}


</script>
</body>
</html>
